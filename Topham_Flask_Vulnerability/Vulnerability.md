# Overview 
For my assignment I decided to look into Python vulnerabilites, my focus targetted FLASK, JINGA2, and SQLLite. During my initial review of the code it appeared to be eligible for a straightforward SQL injection attack by concatinating variables such as user name and user ID into queries. As my research progressed I discovered that FLASK sanitizes string inputs to SQLLite by paramterizing the inputs. 

- Secure Example:
user = db.execute("SELECT * FROM user WHERE username = ? ", (username,)).fetchone()
        - Notice the ? mark and the username in paranthesis, sqlite will sanatize this syntax.

- Insecure Example:
user = db.execute("SELECT * FROM user WHERE username LIKE '{0}'".format(username)).fetchone()
        - This syntax formats itself by calling the format method, this will read the string into the query as is.

As we can see with a bit of careless coding there is a way for the queries to interpret string unsanitized.

For my first injection attacks I discovered a way that the JINGA2 engine reads input from the URL into the HTML. By completing this attack it allows an attacker to inject arbitrary text from the url into the web page. Although the text is not recognizing the html or JavaScript the input itself might redirect users to a separate page if you inject a warning paragraph. 

My Second Injection attack calls a file grabbing method nefariously. At times when programming API's in python, it is not uncommon to conceal an API key in a file outside of the code and then assign it to a variable inside the code. In my example, I displayed a way to call a method that will allow for local file inclusion, with a bit of knowledge in the current paradigm of how people store their keys a good guess is always config.txt. 

# Server Setup

The code includes an injection attack that allows an attacker to inject arbitrary
text from the url into the web page via JINGA2 engine. The vulnerable code
path is as follows:

1. Open VS Code Navigate to the Topham_Flask_Vulerability file in Bash and pip install -e .

2. Setup the environment with the following commands:
    $ export FLASK_APP=flaskr
    $ export FLASK_ENV=development
  
3. Initialize the SQLite database that we will be connecting to in bash by typing in:  $ flask init-db

4. Run the server via Bash by typing in: flask run

5. Ctrl click the url that populates in the terminal

# Vulnerability 1: Injection Attack

The vulnerability can be exploited by following the steps below:

1. Using your browser go to the following URL: http://127.0.0.1:5000/
   
   
2. Click on the Register link in the top right corner of the screen. Enter your credentials that you wish to register your account as.
      -At this point the server will first check to see if the user is already registered and if they are not, the system will execute the following code:
                  db.execute(
                "INSERT INTO user (username, password) VALUES (?, ?)",
                (username, generate_password_hash(password)),

3. Once you register log in using the credentials. 

4. After logged in you will select the create "new" blog entry. Within the navigator bar, above there will be a text noting your user ID.

5. In this injection we will manipulate the browser to change the ID to a different ID.

6. The current URL path should look like this: http://127.0.0.1:5000/create - We will append some additional text at the end. If you
type "?name=Welcome your user ID is 06" -- This will now change th user ID to in this case, 6.

# Vulnerability 2:

The vulnerability can be exploited by following the steps below:

1. Using your browser go to the following URL: http://127.0.0.1:5000/

2. Register as a new user

3. Log in as the user

4. in the URL browser append the following to the code: /secret?name=bob. {{ get_user_file("Config.txt") }}

5. The response should be the API key that is stored locally on the machine.

# Code Snippets

- Visit https://sqliteonline.com/ to see how the database works

 1. Make table 
------------------------------------------------------
DROP TABLE IF EXISTS user;
DROP TABLE IF EXISTS post;

CREATE TABLE user (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  username TEXT UNIQUE NOT NULL,
  password TEXT NOT NULL
);

CREATE TABLE post (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  author_id INTEGER NOT NULL,
  created TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  title TEXT NOT NULL,
  body TEXT NOT NULL,
  FOREIGN KEY (author_id) REFERENCES user (id)
);

---------------------------------------------------------

2. Add users 
INSERT INTO user (username, password) VALUES ('craig', 123)
INSERT INTO user (username, password) VALUES ('bob', 321)


# Payloads

- HTML injection
http://127.0.0.1:5000/create?name=Welcome%20your%20user%20ID%20is%206

- Stealing API Key injection
http://127.0.0.1:5000/secret?name=craig. {{ get_user_file("Config.txt") }}

- Settings and root folder list exposed
curl --request GET http://127.0.0.1:5000/all

-Secret code from dictionary
http://127.0.0.1:5000/secret?name=craig.%20{{person.secret}}